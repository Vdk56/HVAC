

Логины/пароли: admin/admin или user/user

Для того, что бы объяснить возможно непонятные решения в коде я решил, что нужно написать пояснения к коду. Есть 4 класса в коде где, думаю, требуются пояснения. Это классы MainWindow, vent_unit(виджет, который открывает окно отдельного устройства), два класса widget_scheme и widget_chart, которые используются в качестве виджетов в окне устройства класса vent_unit. Разберу каждый, начиная с mainwindow.

MainWindow

При запуске программы и вводе пароля вызывается метод init(), который открывает файл с конфигурацией. Файл конфигурации содержит json массив Devices, каждый элемент которого ассоциируется с устройством(вентиляционной установкой. Далее ВУ) а объекты этого элемента это параметры контроллера и конфигурации ВУ. После того как открыт файл  в методе init() из него(из метода) вызывается метод refresh столько раз сколько устройств присутствует в массиве. В методе refresh создаётся объект QGroupBox и прочие объекты, которые в нем размещены. Объект QGroupBox ассациируется с устройством ВУ. Так же в последнем методе создаются файлы архивы значений и архив сообщений. Что бы обеспечить условия задачи, а именно неограниченное количество добавляемых устройств, было принято решение для всех объектов и величин использовать векторы QVector<тип объекта или переменной>. Input регистры решено объединять в список и создать под эти списки вектор. При каждом вызове refresh создаются новые позиции но всех необходимых векторах. 
Далее, после того как все устройства выведены в виджет методом refresh, программа считывает регистры по сигналу таймера t, и записывает данные в архив по сигналу от таймера tim. Так же через сигнально слотовые связи взаимодействует с другими классами. Так же в refresh объектам QPushButton присваивается имя с соответствующим порядковым номером для того что бы определять для какой именно ВУ будет открываться окно управления через сигнально слотовую связь приписанную в этом же методе. Уже в классе vent_unit в слоте который открывается при получения сигнала от кнопки мы через sender()->objectName().split("_"); определяем номер устройства.
При удалении какого либо устройства программа запускает деструкторы всех объектов данного устройства отображаемых в главном окне. Однако при запуске деструктора QPushButton программа аварийно прекращается и в окне диагностики появляется сообщение о неизвестном исключении, после долгих попыток разобраться было принято решение удалять позицию в векторе, в которой хранится указатель на объект кнопки.
Запрос на чтение Input registers разделён на два. Адресов примерно 140 а читается только 125 адресов сряду. Итого получилось пять запросов.


Widget_chart

С графиком в режиме записи все просто – посылаем в MainWindow сигнал с номером открытого окна ВУ для определения позиции в QVector и получаем нужные значения и добавляем их в объекты QLineSeries. Единственное с чем пришлось повозиться это отображение координат курсора на графике. Ниже приведено решение:

if (event->type() == QEvent::MouseMove){
          QMouseEvent *mouseEvent = (QMouseEvent *) event;
          chart->setCursor(Qt::CrossCursor);
         auto const widgetPos = mouseEvent->localPos();
         auto const scenePos = chart->mapToScene(QPoint(static_cast<int>(widgetPos.x()),                static_cast<int>(widgetPos.y())));  
        auto const chartItemPos = chart->mapFromScene(scenePos);
         auto const valueGivenSeries = chart->mapToValue(chartItemPos);
        qreal d= valueGivenSeries.x();
        
         QDateTime x = QDateTime::fromMSecsSinceEpoch(d);
          int y = valueGivenSeries.y();
          ui->coord_lab_x->setText(x.toString("dd/MM/yyyy hh:mm:ss"));
         ui->coord_lab_y->setText(QString::number(y)+" °C");
}


Где chart это объект QChart, а coord_lab это лэйблы, в которые выводятся значения координат.


Есть  также 2 режима: чтение из архива и сравнение. Для начала про архив.
При нажатии под графиком кнопки «Архив» очищаются все объекты QLineSeries и все кнопки, которые были disabled становятся enabled. При нажатии кнопки перейти сравнивается самая ранняя дата в архиве и введенная дата. Если последняя указывает на более раннее время, то появляется уведомление, что такой даты нет и нужно ввести другую. Если же такая дата есть то дальше по коду вызывается метод get_string_number, который принимает нужную дату, определяет номер строки в архиве и возвращает его. Далее берутся 50 строк до и 50 полученного номера «центральной» строки. Если строк до или после меньше чем 50 то берём столько, сколько есть, но не меньше нуля. Сдвиг вправо и влево осуществляется с проверкой, что бы «центральная» строка не стала меньше нуля или больше количества строк архива.
Режим сравнения работает если выбраны даты не ранее самой ранней даты архива(используем метод erliest_date()) и выбранный интервал больше нуля. Далее получаем номер срок для каждого графика из метода get_string_number. Получаем значений величины методом get_list_for_goButton(). Настраиваем оси времени. Не забываем отчистить вектор list_to_chart, через который мы получили список и загружаем значения для другого графика под который мы создали экземпляры осей, которые будут удалены при переходе в режим архива или записи.

Widget_chart

Здесь, хоть кода и не мало, в целом смысл простой. Получаем номер устройства, открываем файл с конфигурацией, получаем код SCADA и код CPU и в соответствии с ними рисуем загручаем картинки какие нужны и рисуем мнемосхему. Через сигналы/слоты получаем от MainWindow данные из регистров и в соответствии с ними рисуем мнемосхему, отображаем и скрываем изображения. 

vent_unit
В этом классе как и в предыдущем есть метод с множеством операторов if, написанный для определения ошибок, добавлении их в таблицу и записи в архив. Таймер сигналом timeout вызывает слот, который испускает сигнал unitS, с помощью которого мы затем получаем код аварий в векторе alarm_code класса MainWindow.  С помощью сигналов/слотов получаем из соответствующей устройству позиции в векторе alarm_code класса MainWindow код аварии и сравниваем его с кодом, который мы получили в предыдущий раз c помощью оператора &. Если ошибки не было и она появилась, то она заносится в журнал и таблицу. В таблице фон строки этой ошибки окрашевается в красный до тех пор пока ошибка не перестанет быть активной, что проверяется там же, так же оператором if.

Думаю остальное все понятно.
